Synchronization

  Semaphores
    信号量是一种同步机制，用于控制并访问共享资源的方式。
    用于多线程或多进程，用于保护临界区的访问
    会维护一个内部的计数器，表示可用资源数量
    当一个线程需要访问共享资源，需要先获取信号量
      如果计数器大于零，说明可用资源存在，这时候计数器减一，表示已经用掉一个资源
      如果计数器等于零，则线程需要等待，直到其他进程释放一个信号量，使得计数器增加
      
  API
    sem = sem_create(count);
    down() or P()
      decrease by 1, block if already 0
    up() or V()
      increase by 1, wake up one of the waiting thread
      
  Binary semaphore
    0 or 1
    如果是1，表示锁可以被获取，如果是0，表示锁不可以被获取，也就是已经被其他线程占用
    如果是锁，线程会不断检查有没有可以用的锁，如果不行，就会进行循环等待
    而binary semaphore里面，等待的线程会直接被block，不会占用cpu资源
    Initial value is generally 1 (ie free)
    
    sem = sem_create(1)
    down(sem);
      Critical Section;
    up(sem);
    
    
  Counted semaphore
    可以用来表示具有多个单位的资源
    计数信号量是一种计数器，用来追踪可用资源的数量
    当一个线程需要获取资源，它会尝试获取计数信号量
      如果计数信号量大于所需资源数量，可以继续执行
      如果小于，线程会被block
    避免过度资源竞争和资源耗尽，也就是可以避免超过最大容量
    
    sem_packet = sem_create(0);   创建一个技术信号量，初始值为0，用于管理可用的数据包
    
    while (1) {
      x = get_network_packet();   获取一个网络数据包
      enqueue(packetq, x);        把这个网络数据包放入数据包队列
      up(sem_packet);             可用数据包 + 1
    }
    
    while (1) {
      down(sem_packet);           取出一个网络数据包
      x = dequeue(packetq);       把这个数据包拿出数据包队列
      process_contents(x);        可用数据包 - 1
    }
    
    
Producer-consumer problem
  两个或多个线程通过一个循环缓冲区进行通信，其中一些线程负责生产数据，而其他线程负责消费数据
    bounded buffer: 固定大小的循环数据缓冲区，用来储存生产者
